{"ast":null,"code":"import { count_occurences } from './helpers';\nimport close_braces from './closeBraces'; // Takes a `template` where character placeholders\n// are denoted by 'x'es (e.g. 'x (xxx) xxx-xx-xx').\n//\n// Returns a function which takes `value` characters\n// and returns the `template` filled with those characters.\n// If the `template` can only be partially filled\n// then it is cut off.\n//\n// If `should_close_braces` is `true`,\n// then it will also make sure all dangling braces are closed,\n// e.g. \"8 (8\" -> \"8 (8  )\" (iPhone style phone number input).\n//\n\nexport default function (template) {\n  var placeholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n  var should_close_braces = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (!template) {\n    return function (value) {\n      return {\n        text: value\n      };\n    };\n  }\n\n  var characters_in_template = count_occurences(placeholder, template);\n  return function (value) {\n    if (!value) {\n      return {\n        text: '',\n        template: template\n      };\n    }\n\n    var value_character_index = 0;\n    var filled_in_template = ''; // Using `.split('')` here instead of normal `for ... of`\n    // because the importing application doesn't neccessarily include an ES6 polyfill.\n    // The `.split('')` approach discards \"exotic\" UTF-8 characters\n    // (the ones consisting of four bytes)\n    // but template placeholder characters don't fall into that range\n    // and appending UTF-8 characters to a string in parts still works.\n\n    for (var _iterator = template.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var character = _ref;\n\n      if (character !== placeholder) {\n        filled_in_template += character;\n        continue;\n      }\n\n      filled_in_template += value[value_character_index];\n      value_character_index++; // If the last available value character has been filled in,\n      // then return the filled in template\n      // (either trim the right part or retain it,\n      //  if no more character placeholders in there)\n\n      if (value_character_index === value.length) {\n        // If there are more character placeholders\n        // in the right part of the template\n        // then simply trim it.\n        if (value.length < characters_in_template) {\n          break;\n        }\n      }\n    }\n\n    if (should_close_braces) {\n      filled_in_template = close_braces(filled_in_template, template);\n    }\n\n    return {\n      text: filled_in_template,\n      template: template\n    };\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,gBAAT,QAAiC,WAAjC;AACA,OAAOC,YAAP,MAAyB,eAAzB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,UAASC,QAAT,EACf;AAAA,MADkCC,WAClC,uEADgD,GAChD;AAAA,MADqDC,mBACrD;;AACC,MAAI,CAACF,QAAL,EACA;AACC,WAAO,iBAAK;AAAA,aAAK;AAAEG,YAAI,EAAEC;AAAR,OAAL;AAAZ;AACA;;AAED,MAAMC,sBAAsB,GAAGP,gBAAgB,CAACG,WAAD,EAAcD,QAAd,CAA/C;AAEA,SAAO,UAASI,KAAT,EACP;AACC,QAAI,CAACA,KAAL,EACA;AACC,aAAO;AAAED,YAAI,EAAE,EAAR;AAAYH,gBAAQ,EAARA;AAAZ,OAAP;AACA;;AAED,QAAIM,qBAAqB,GAAG,CAA5B;AACA,QAAIC,kBAAkB,GAAG,EAAzB,CAPD,CASC;AACA;AACA;AACA;AACA;AACA;;AACA,yBAAwBP,QAAQ,CAACQ,KAATR,CAAe,EAAfA,CAAxB,kHACA;AAAA;;AAAA;AAAA;AAAAS;AAAA;AAAAC;AAAA;AAAAD;AAAA;;AAAA,UADWE,SACX;;AACC,UAAIA,SAAS,KAAKV,WAAlB,EACA;AACCM,0BAAkB,IAAII,SAAtBJ;AACA;AACA;;AAEDA,wBAAkB,IAAIH,KAAK,CAACE,qBAAD,CAA3BC;AACAD,2BAAqB,GARtB,CAUC;AACA;AACA;AACA;;AACA,UAAIA,qBAAqB,KAAKF,KAAK,CAACQ,MAApC,EACA;AACC;AACA;AACA;AACA,YAAIR,KAAK,CAACQ,MAANR,GAAeC,sBAAnB,EACA;AACC;AACA;AACD;AACD;;AAED,QAAIH,mBAAJ,EACA;AACCK,wBAAkB,GAAGR,YAAY,CAACQ,kBAAD,EAAqBP,QAArB,CAAjCO;AACA;;AAED,WAAO;AAAEJ,UAAI,EAAEI,kBAAR;AAA4BP,cAAQ,EAARA;AAA5B,KAAP;AAhDD;AAkDA","names":["count_occurences","close_braces","template","placeholder","should_close_braces","text","value","characters_in_template","value_character_index","filled_in_template","split","_ref","_i","character","length"],"sources":["/Applications/Sandali/DietitianWebsite/client/node_modules/input-format/source/templateFormatter.js"],"sourcesContent":["import { count_occurences } from './helpers'\r\nimport close_braces from './closeBraces'\r\n\r\n// Takes a `template` where character placeholders\r\n// are denoted by 'x'es (e.g. 'x (xxx) xxx-xx-xx').\r\n//\r\n// Returns a function which takes `value` characters\r\n// and returns the `template` filled with those characters.\r\n// If the `template` can only be partially filled\r\n// then it is cut off.\r\n//\r\n// If `should_close_braces` is `true`,\r\n// then it will also make sure all dangling braces are closed,\r\n// e.g. \"8 (8\" -> \"8 (8  )\" (iPhone style phone number input).\r\n//\r\nexport default function(template, placeholder = 'x', should_close_braces)\r\n{\r\n\tif (!template)\r\n\t{\r\n\t\treturn value => ({ text: value })\r\n\t}\r\n\r\n\tconst characters_in_template = count_occurences(placeholder, template)\r\n\r\n\treturn function(value)\r\n\t{\r\n\t\tif (!value)\r\n\t\t{\r\n\t\t\treturn { text: '', template }\r\n\t\t}\r\n\r\n\t\tlet value_character_index = 0\r\n\t\tlet filled_in_template = ''\r\n\r\n\t\t// Using `.split('')` here instead of normal `for ... of`\r\n\t\t// because the importing application doesn't neccessarily include an ES6 polyfill.\r\n\t\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\r\n\t\t// (the ones consisting of four bytes)\r\n\t\t// but template placeholder characters don't fall into that range\r\n\t\t// and appending UTF-8 characters to a string in parts still works.\r\n\t\tfor (const character of template.split(''))\r\n\t\t{\r\n\t\t\tif (character !== placeholder)\r\n\t\t\t{\r\n\t\t\t\tfilled_in_template += character\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tfilled_in_template += value[value_character_index]\r\n\t\t\tvalue_character_index++\r\n\r\n\t\t\t// If the last available value character has been filled in,\r\n\t\t\t// then return the filled in template\r\n\t\t\t// (either trim the right part or retain it,\r\n\t\t\t//  if no more character placeholders in there)\r\n\t\t\tif (value_character_index === value.length)\r\n\t\t\t{\r\n\t\t\t\t// If there are more character placeholders\r\n\t\t\t\t// in the right part of the template\r\n\t\t\t\t// then simply trim it.\r\n\t\t\t\tif (value.length < characters_in_template)\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (should_close_braces)\r\n\t\t{\r\n\t\t\tfilled_in_template = close_braces(filled_in_template, template)\r\n\t\t}\r\n\r\n\t\treturn { text: filled_in_template, template }\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}